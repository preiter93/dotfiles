{
    "switch statement": {
        "prefix": "switch",
        "body": "switch ${1:expression} {\ncase ${2:condition}:\n\t$0\n}",
        "description": "Snippet for switch statement"
    },
    "select statement": {
        "prefix": "sel",
        "body": "select {\ncase ${1:condition}:\n\t$0\n}",
        "description": "Snippet for select statement"
    },
    "for n statement": {
        "prefix": "fori",
        "body": "for ${1:i} := ${2:0}; $1 < ${3:count}; $1${4:++} {\n\t$0\n}",
        "description": "Snippet for a for loop"
    },
    "for range statement": {
        "prefix": "forr",
        "body": "for ${1:_, }${2:v} := range ${3:v} {\n\t$0\n}",
        "description": "Snippet for a for range loop"
    },
    "if else statement": {
        "prefix": "ifelse",
        "body": "if ${1:condition} {\n\t$2\n} else {\n\t$0\n}",
        "description": "Snippet for if else"
    },
    "if err != nil": {
        "prefix": "iferr",
        "body": "if err != nil {\n\t${1:return ${2:nil, }${3:err}}\n}",
        "description": "Snippet for if err != nil"
    },
    "fmt.Printf": {
        "prefix": "ff",
        "body": "fmt.Printf(\"$1 %v\", ${2:var})",
        "description": "Snippet for fmt.Printf()"
    },
    "logger.Printf": {
        "prefix": "logger",
        "body": "logger.Infof(\"$1 %v\", ${2:var})",
        "description": "Snippet for fmt.Printf()"
    },
    "if key in a map": {
        "prefix": "keyInMap",
        "body": "if val, ok := ${1:myMap}[${2:myKey}]; ok {\n\t$3\n}"
    },
    "table driven test": {
        "prefix": "table",
        "body": [
            "func Test_test(t *testing.T) {",
            "	tests := []struct {",
            "		name    string",
            "		want    string",
            "		wantErr error",
            "	}{",
            "		{",
            "			name:    \"happy path\",",
            "			wantErr: nil,",
            "		},",
            "		{",
            "			name:    \"error\",",
            "			wantErr: status.Error(codes.InvalidArgument, \"invalid argument\"),",
            "		},",
            "	}",
            "	for _, tc := range tests {",
            "		t.Run(tc.name, func(t *testing.T) {",
            "			resp, err := myFunction()",
            "			if diff := cmp.Diff(tc.wantErr, err, cmpopts.EquateErrors()); diff != \"\" {",
            "				t.Errorf(\"error mismatch (-want, +got):\\n%s\", diff)",
            "			}",
            "			opts := []cmp.Option{cmpopts.IgnoreUnexported(pb.Date{})}",
            "			if diff := cmp.Diff(tc.want, resp, opts...); diff != \"\" {",
            "				t.Errorf(\"response mismatch (-want, +got):\\n%s\", diff)",
            "			}",
            "		})",
            "	}",
            "}"
        ],
        "description": "Create a table-driven test"
    }
}
